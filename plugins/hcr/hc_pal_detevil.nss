//  ----------------------------------------------------------------------------
//  hc_pal_detevil
//  ----------------------------------------------------------------------------
/*
    Hardcore Paladin Detect Evil Tool - OnActivateItem script.

    Enables a Paladin to sense evil aura's in the surrounding area.  The amount
    of information depends on the number of rounds they use this power for.


    Note To Builders
    ----------------
    You can use the HC_VAR_DETECT_EVIL_OBJECT_POWER global variable to flag
    objects as "Evil". Any positive value will represent the "level" of the
    object. Ensure you use the variable's name (below) and not the identifier.


    3rd Edition Implementation
    --------------------------
    Round 1 = presence or absence
    Round 2 = number of aura, strength of the strongest, may be overwhelmed
    Round 3 = power and location (or direction if out of LoS) of each aura

    Overwhelmed = strongest aura is overwhelming, aura strenth is at least twice
    PCs character levels = stunned for 1 round and spell ends.

    Evil Power = the highest applicable value calculated using the following
    table:

        Evil Source     Evil Power
        -----------     -----------
         Outsider        HD
         Elemental       HD / 2
         Undead          HD / 2
         Other Creature  HD / 5
         Cleric          Class Level
         Other Object    HC_VAR_DETECT_EVIL_OBJECT_POWER

    Aura Strength = calcualted using the following table:

        Evil Power      Aura Strength
        ----------      -------------
         0-1             Faint
         2-4             Moderate
         5-10            Strong
         11+             Overwhelming


    Known Issues @ 3.02
    -------------------
    - LoS condition cannot be implemented properly implemented however creatures
      in the effect area but out of LoS can either be included or excluded using
      the bUseLoS variable.
    - The phrase "cleric of an evil deity" is necessarily interpretated as an
      evil cleric since HCR does not support a deity system at this time.
    - Penetration of solid barriers is not implemented.
    - Detecting lingering auras is not implemented.
    - Evil items and spells detection is not implemented.
*/
//  ----------------------------------------------------------------------------
/*
    HCR 3.02 - 12 July 2004
    - rewritten

    Credits:
    - Archaegeo
    - Wraithdrit
    - Velmar
*/
//  ----------------------------------------------------------------------------
#include "hc_inc"
#include "hc_inc_timecheck"
#include "hc_text_detevil"


//  ----------------------------------------------------------------------------
//  CONSTANTS
//  ----------------------------------------------------------------------------

// controls the size of the detect evil shape. Default = 18.3m (60 feet)
const float HC_DETECT_EVIL_SHAPE_SIZE       = 18.3;

// controls if LOS is used should when detecting sources. Default = TRUE.
const int HC_DETECT_EVIL_SHAPE_LOS          = TRUE;

// controls the number of seconds allowed before subsequent detect evil checks
// stop being considered to be consecutive. Default = 12 seconds.
const int HC_DETECT_EVIL_TIMEOUT            = 12;

// evil power level constants
const int HC_DETECT_EVIL_POWER_FAINT        = 0;
const int HC_DETECT_EVIL_POWER_MODERATE     = 2;
const int HC_DETECT_EVIL_POWER_STRONG       = 5;
const int HC_DETECT_EVIL_POWER_OVERWHELM    = 11;

// aura strength constants
const int HC_DETECT_EVIL_AURA_FAINT         = 1;
const int HC_DETECT_EVIL_AURA_MODERATE      = 2;
const int HC_DETECT_EVIL_AURA_STRONG        = 3;
const int HC_DETECT_EVIL_AURA_OVERWHELM     = 4;

// variables names
const string HC_VAR_DETECT_EVIL_LAST_USED    = "DETECTEVILTIME";
const string HC_VAR_DETECT_EVIL_NUM_ROUNDS   = "DETECTEVILROUNDS";
const string HC_VAR_DETECT_EVIL_OBJECT_POWER = "EVILPOWER";


//  ----------------------------------------------------------------------------
//  PROTOTYPES
//  ----------------------------------------------------------------------------


// Returns a location fDistance infront of oSource according to their facing.
//  - oSource:          any object
//  - fDistance:        distance to new location
location GetLocationInFront(object oSource, float fDistance);

// Returns a evil power rating for oSource. The evil power rating cannot exceed
// their hit dice or level and is normally a fraction there of.
//  * Returns:          evil power rating between 0 and 60
//  * OnError:          returns -1
int HC_DetectEvil_GetEvilPower(object oSource);

// Returns the stregth of the aura generated by an evil rating power.
//  - nEvilPower:       evil power rating between 0 and 60
//  * Returns:          HC_DETECT_EVIL_AURA_* constant
int HC_DetectEvil_GetAuraStrength(int nEvilPower);

// Returns a description of the aura strength specified.
//  - nAuraStrength:    HC_DETECT_EVIL_AURA_* constant
//  * Returns:          HC_TEXT_DETECT_EVIL_AURA_* constant
string HC_DetectEvil_GetAuraStrengthString(int nAuraStrength);

// Wrapper for the various steps required to Overwhelm oPC
// NOTE: this was done to enable DelayCommand to be used if desired
//  - oPC:              paladin character
void HC_DetectEvil_Overwhelmed(object oPC);


//  ----------------------------------------------------------------------------
//  FUNCTIONS
//  ----------------------------------------------------------------------------


location GetLocationInFront(object oSource, float fDistance)
{
    // get current co-ordinates and facing
    vector vSource = GetPosition(oSource);
    float fSource = GetFacing(oSource);

    // calculate new co-ordinates (some circle algebra/geometry: centre vSource,
    // radius fDistance, angle fSource)
    float fX = vSource.x + (fDistance * cos(fSource));
    float fY = vSource.y + (fDistance * sin(fSource));

    // return a new location
    return Location(GetArea(oSource), Vector(fX, fY, vSource.z), fSource);
}


int HC_DetectEvil_GetEvilPower(object oSource)
{
    int nCur;
    int nMax;

    // sanity check
    if(GetIsObjectValid(oSource) == FALSE)
    {
        // source is invalid: return an error
        return -1;
    }

    // cleric = class level (i.e. NOT character level)
    nMax = GetLevelByClass(CLASS_TYPE_CLERIC, oSource);

    if(GetLevelByClass(CLASS_TYPE_OUTSIDER, oSource))
    {
        // outsider by HD, if higher update max
        nCur = GetHitDice(oSource);
        nMax = (nMax > nCur) ? nMax : nCur;
    }

    if(GetLevelByClass(CLASS_TYPE_UNDEAD, oSource))
    {
        // undead = HD / 2, if higher update max
        nCur = GetHitDice(oSource) / 2;
        nMax = (nMax > nCur) ? nMax : nCur;
    }

    if(GetLevelByClass(CLASS_TYPE_ELEMENTAL, oSource))
    {
        // elemental = HD / 2, if higher update max
        nCur = GetHitDice(oSource) / 2;
        nMax = (nMax > nCur) ? nMax : nCur;
    }

    // catch all: either a creature or not!
    if(GetObjectType(oSource) == OBJECT_TYPE_CREATURE)
    {
        // creature = HD / 5, if higher update max
        nCur = GetHitDice(oSource) / 5;
        nMax = (nMax > nCur) ? nMax : nCur;
    }
    else
    {
        // object = HC_VAR_DETECT_EVIL_OBJECT_POWER, if higher update max
        nCur = GetLocalInt(oSource, HC_VAR_DETECT_EVIL_OBJECT_POWER);
        nMax = (nMax > nCur) ? nMax : nCur;
    }

    return nMax;
}


int HC_DetectEvil_GetAuraStrength(int nEvilPower)
{
    int nRet;

    // compare power rating with power levels to determine aura stength
    if(nEvilPower < HC_DETECT_EVIL_POWER_MODERATE)
    {
        nRet = HC_DETECT_EVIL_AURA_FAINT;
    }
    else if(nEvilPower < HC_DETECT_EVIL_POWER_STRONG)
    {
        nRet = HC_DETECT_EVIL_AURA_MODERATE;
    }
    else if(nEvilPower < HC_DETECT_EVIL_POWER_OVERWHELM)
    {
        nRet = HC_DETECT_EVIL_AURA_STRONG;
    }
    else
    {
        nRet = HC_DETECT_EVIL_AURA_OVERWHELM;
    }

    return nRet;
}


string HC_DetectEvil_GetAuraStrengthString(int nAuraStrength)
{
    string sRet;

    switch(nAuraStrength)
    {
        // parse aura power to return appropriate "has a _____ aura" string
        case HC_DETECT_EVIL_AURA_FAINT:     sRet += HC_TEXT_DETECT_EVIL_AURA_FAINT;     break;
        case HC_DETECT_EVIL_AURA_MODERATE:  sRet += HC_TEXT_DETECT_EVIL_AURA_MODERATE;  break;
        case HC_DETECT_EVIL_AURA_STRONG:    sRet += HC_TEXT_DETECT_EVIL_AURA_STRONG;    break;
        case HC_DETECT_EVIL_AURA_OVERWHELM: sRet += HC_TEXT_DETECT_EVIL_AURA_OVERWHELM; break;
    }

    return sRet;
}


void HC_DetectEvil_Overwhelmed(object oPC)
{
    // inform player
    SendMessageToPC(oPC, HC_TEXT_DETECT_EVIL_STUNNED);

    // stun player
    effect eStun = EffectStunned();
    ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eStun, oPC, 6.0);

    // reset the number of consecutive rounds to 0
    DeleteLocalInt(oPC, HC_VAR_DETECT_EVIL_NUM_ROUNDS);
    return;
}


//  ----------------------------------------------------------------------------
//  MAIN
//  ----------------------------------------------------------------------------

void main()
{
    object oPC = OBJECT_SELF;
    vector vPC = GetPosition(oPC);

    //  ------------------------------------------------------------------------
    //  Preliminaries
    //  ------------------------------------------------------------------------

    // get the current server time
    int nThisTime = SecondsSinceBegin();

    // get and update the time ability was last used
    int nLastTime = GetLocalInt(oPC, HC_VAR_DETECT_EVIL_LAST_USED);
    SetLocalInt(oPC, HC_VAR_DETECT_EVIL_LAST_USED, nThisTime);

    // get, check and update the number of consecutive rounds of use
    int nRound = GetLocalInt(oPC, HC_VAR_DETECT_EVIL_NUM_ROUNDS) + 1;
    if(nThisTime > nLastTime + HC_DETECT_EVIL_TIMEOUT || nRound > 3)
    {
        // too much time has elapsed since the last check or this will be the
        // 4th round: either way restart process
        nRound = 1;
    }
    SetLocalInt(oPC, HC_VAR_DETECT_EVIL_NUM_ROUNDS, nRound);


    //  ------------------------------------------------------------------------
    //  Detection and Round 3 Feedback
    //  ------------------------------------------------------------------------

    int nNumAura;
    int nCurPower;
    int nMaxPower;

    // create a location based on PC's position and facing
    location lTarget = GetLocationInFront(oPC, HC_DETECT_EVIL_SHAPE_SIZE);

    // object type filter
    int nObjectTypes = OBJECT_TYPE_CREATURE | OBJECT_TYPE_DOOR | OBJECT_TYPE_PLACEABLE;

    // loop through all targets in effect area
    object oTarget = GetFirstObjectInShape(SHAPE_CONE, HC_DETECT_EVIL_SHAPE_SIZE, lTarget, HC_DETECT_EVIL_SHAPE_LOS, nObjectTypes, vPC);
    while(GetIsObjectValid(oTarget))
    {
        int bThisIsEvil = FALSE;

        // check if the target is evil
        if(GetObjectType(oTarget) == OBJECT_TYPE_CREATURE
        && GetAlignmentGoodEvil(oTarget) == ALIGNMENT_EVIL)
        {
            // target is an evil creature
            bThisIsEvil = TRUE;
        }
        else if(GetLocalInt(oTarget, HC_VAR_DETECT_EVIL_OBJECT_POWER) > 0)
        {
            // target is an object with a positive evil power level
            bThisIsEvil = TRUE;
        }

        // target IS evil
        if(bThisIsEvil)
        {
            // always
            nNumAura++;

            // round 1
            if(nRound == 1)
            {
                // that evil was detected is sufficient
                break;
            }

            // round 2+
            if(nRound >= 2)
            {
                // get the current evil power, if higher update max power
                nCurPower = HC_DetectEvil_GetEvilPower(oTarget);
                nMaxPower = (nCurPower > nMaxPower) ? nCurPower : nMaxPower;
            }

            // round 3
            if(nRound == 3)
            {
                // highlight current target
                effect eVis  = EffectVisualEffect(VFX_DUR_PARALYZED);
                ApplyEffectToObject(DURATION_TYPE_TEMPORARY, eVis, oTarget, 3.0);

                // inform PC about current target
                string sASS = HC_DetectEvil_GetAuraStrengthString( HC_DetectEvil_GetAuraStrength(nCurPower));
                SendMessageToPC(oPC, GetName(oTarget) + HC_TEXT_DETECT_EVIL_IS_EVIL + sASS);
            }
        }

        // get the next target in the effect area
        oTarget = GetNextObjectInShape(SHAPE_CONE, HC_DETECT_EVIL_SHAPE_SIZE, lTarget, HC_DETECT_EVIL_SHAPE_LOS, nObjectTypes, vPC);
    }


    //  ------------------------------------------------------------------------
    //  Rounds 1 and 2 Feedback
    //  ------------------------------------------------------------------------

    if(nNumAura > 0)
    {
        if(nRound == 1)
        {
            // inform PC of single source of evil (may be more but they can't tell)
            SendMessageToPC(oPC, HC_TEXT_DETECT_EVIL_SENSE + HC_TEXT_DETECT_EVIL_SOURCE);
        }
        else if(nRound == 2)
        {
            if(nNumAura == 1)
            {
                // inform PC of single source of evil
                SendMessageToPC(oPC, HC_TEXT_DETECT_EVIL_SENSE + HC_TEXT_DETECT_EVIL_SOURCE);
            }
            else
            {
                // inform PC of multiple sources of evil
                SendMessageToPC(oPC, HC_TEXT_DETECT_EVIL_SENSE + IntToString(nNumAura) + HC_TEXT_DETECT_EVIL_SOURCES);
            }

            // inform PC about strongest aura strength
            string sASS = HC_DetectEvil_GetAuraStrengthString( HC_DetectEvil_GetAuraStrength(nMaxPower));
            SendMessageToPC(oPC, HC_TEXT_DETECT_EVIL_MOST_POTENT + sASS);

            // if aura strength "is overwhelming and ... 'at least' twice ... character level"
            if(HC_DetectEvil_GetAuraStrength(nMaxPower) == HC_DETECT_EVIL_AURA_OVERWHELM
            && nMaxPower >= GetHitDice(oPC) * 2)
            {
                // the PC is overwhelmed
                HC_DetectEvil_Overwhelmed(oPC);
            }
        }
    }
    else
    {
        // no evil
        SendMessageToPC(oPC, HC_TEXT_DETECT_EVIL_NO_EVIL);
    }
}

